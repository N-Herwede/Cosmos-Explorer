<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Procedural Earth - Noah Herwede</title>
    <style>
        body, html { margin: 0; padding: 0; overflow: hidden; background: transparent; }
        canvas { display: block; width: 100vw; height: 100vh; }
    </style>
</head>
<body>
    <canvas id="glcanvas"></canvas>

    <script id="vs" type="x-shader/x-vertex">
        attribute vec2 position;
        void main() {
            gl_Position = vec4(position, 0.0, 1.0);
        }
    </script>

    <script id="fs" type="x-shader/x-fragment">
        #extension GL_OES_standard_derivatives : enable
        precision highp float;

        uniform vec3 iResolution;
        uniform float iTime;

        // --- CONSTANTS ---
        const float SEED = 0.0;
        const float PLANET_RADIUS = 0.75;
        const vec3 ROTATION_AXIS = vec3(0.3, 1.0, 0.0);
        const float ROTATION_SPEED = 0.1;
        const vec3 LAND_COLOR = vec3(0.2, 0.4, 0.0);
        const vec3 JUNGLE_COLOR = vec3(0.0, 0.2, 0.0);
        const vec3 DESERT_COLOR = vec3(1.0, 0.8, 0.6);
        const vec3 SNOW_COLOR = vec3(0.85, 0.85, 0.9);
        const float OCEAN_SIZE = 0.57;
        const vec3 OCEAN_COLOR = vec3(0.1, 0.15, 0.35);
        const vec3 ATMOSPHERE_COLOR = vec3(0.3, 0.5, 1.0);
        const float ATMOSPHERE_DENSITY = 1.8;
        const vec3 DAWN_COLOR = vec3(0.4, 0.6, 1.0);
        const vec3 SUNSET_COLOR = vec3(0.2, 0.4, 0.9);
        const vec3 CLOUD_COLOR = vec3(1.0);
        const vec3 LIGHT1_POS = vec3(8.0, 8.0, -8.0);
        const vec3 LIGHT2_POS = vec3(8.0, 12.0, 4.0);
        const float PI = 3.14159265;
        const float TAU = 6.2831853;

        // --- NOISE FUNCTIONS ---
        float hash12(vec2 p, float scale) {
            p = mod(p, scale); p.y += SEED;
            return fract(sin(dot(p, vec2(12.9898, 4.1414))) * 43758.5453);
        }

        float noise(vec2 p, float scale) {
            p *= scale; vec2 f = fract(p); p = floor(p);
            f = f * f * (3.0 - 2.0 * f);
            return mix(mix(hash12(p, scale), hash12(p + vec2(1, 0), scale), f.x),
                       mix(hash12(p + vec2(0, 1), scale), hash12(p + vec2(1, 1), scale), f.x), f.y);
        }

        float fbm(vec2 p, float scale, int octaves) {
            float s = 0.0, m = 0.0, a = 1.0;
            for(int i = 0; i < 10; i++) {
                if(i >= octaves) break;
                s += a * noise(p, scale); m += a; a *= 0.6; scale *= 2.0;
            }
            return s / m;
        }

        float swirly_fbm(vec2 p, float scale, int octaves) {
            p -= iTime * 0.004;
            float s = 0.0, m = 0.0, a = 1.0;
            for(int i = 0; i < 10; i++) {
                if(i >= octaves) break;
                s += a * noise(p + iTime * 0.004 * a, scale);
                m += a; a *= 0.6; scale *= 2.0;
                p += vec2(cos(s * TAU), sin(s * TAU)) / scale * 0.4;
            }
            return s / m;
        }

        // --- ROTATION & PROJECTION ---
        vec3 rot_axis(vec3 v, vec3 axis, float angle) {
            axis = normalize(axis);
            vec4 q = vec4(cos(angle * 0.5), axis * sin(angle * 0.5));
            return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
        }

        vec3 get_norm(vec2 uv, float z) {
            vec3 n = rot_axis(vec3(uv, z), ROTATION_AXIS, iTime * ROTATION_SPEED);
            return n;
        }

        vec2 mercator(vec3 n) {
            return vec2(atan(n.z, n.x) * 0.5, acos(-n.y)) / PI;
        }

        vec3 baseColor(vec3 n) {
            vec3 norm = rot_axis(normalize(n), ROTATION_AXIS, iTime * ROTATION_SPEED);
            vec2 muv = mercator(norm);

            float continent = fbm(muv, 4.0, 7);
            float temp = fbm(muv * 3.0 + vec2(31.33, 0.0), 1.0, 4);
            float humid = fbm(muv * 3.0 - vec2(54.1, 0.0), 1.0, 4);

            float f = 0.01;
            vec3 col = LAND_COLOR;
            float land = smoothstep(f, 0.0, OCEAN_SIZE - continent);
            col = mix(col, DESERT_COLOR, smoothstep(0.25, 0.1, humid));
            col = mix(col, JUNGLE_COLOR, smoothstep(0.1, 0.3, humid) * smoothstep(0.3, 0.4, temp));
            col = mix(col, SNOW_COLOR, smoothstep(0.3, 0.2, temp));
            col *= sqrt(continent) * land * 1.2 * smoothstep(1.0, 0.99, abs(norm.y));

            float ocean = smoothstep(OCEAN_SIZE, OCEAN_SIZE - f, continent);
            col += (1.0 - continent) * ocean * OCEAN_COLOR;
            col.rgb *= sqrt(1.0 + 0.1 * cos(sqrt(continent) * 512.0));

            return col;
        }

        // --- RENDER PASSES ---
        vec4 planet(vec2 uv) {
            float len = length(uv);
            float f = fwidth(len);
            if (len > 1.0 - f * 0.3) return vec4(0);
            float z = -sqrt(0.999 - len * len);
            vec3 norm = get_norm(uv, z);
            vec2 muv = mercator(norm);

            vec3 col = vec3(0);
            float continent = fbm(muv, 4.0, 7);
            float temp = fbm(muv * 3.0 + vec2(31.33, 0.0), 1.0, 4);
            float humid = fbm(muv * 3.0 - vec2(54.1, 0.0), 1.0, 4);

            float land = smoothstep(f, 0.0, OCEAN_SIZE - continent);
            col += LAND_COLOR;
            col = mix(col, DESERT_COLOR, smoothstep(0.25, 0.1, humid));
            col = mix(col, JUNGLE_COLOR, smoothstep(0.1, 0.3, humid) * smoothstep(0.3, 0.4, temp));
            col = mix(col, SNOW_COLOR, smoothstep(0.3, 0.2, temp));
            col *= sqrt(continent) * land * 1.2 * smoothstep(1.0, 0.99, abs(norm.y));

            float ocean = smoothstep(OCEAN_SIZE, OCEAN_SIZE - f, continent);
            col += (1.0 - continent) * ocean * OCEAN_COLOR;
            col.rgb *= sqrt(1.0 + 0.1 * cos(sqrt(continent) * 512.0));

            return vec4(col, smoothstep(1.0, 1.0 - f * 2.0, len));
        }

        vec4 clouds(vec2 uv) {
            float len = length(uv);
            float f = fwidth(len);
            if (len > 1.0 - f * 0.3) return vec4(0);
            float z = -sqrt(0.999 - len * len);
            vec3 norm = get_norm(uv, z);
            vec2 muv = mercator(norm);
            float cl = swirly_fbm(-muv, 11.0, 6) * smoothstep(1.0, 0.99, abs(norm.y));
            cl = exp(-pow(cl, 6.0) * 32.0);
            return vec4(CLOUD_COLOR, cl);
        }

        vec4 atmosphere(vec2 uv) {
            float len = length(uv);
            float altitude = max(0.0, len - PLANET_RADIUS);
            float z = -sqrt(max(0.0, 0.999 - len * len));
            vec3 norm = vec3(uv, z);

            // Bigger, more spread halo like Neptune
            float density = exp(-altitude * 5.0) * len * len * ATMOSPHERE_DENSITY * 0.7;
            vec3 col = ATMOSPHERE_COLOR;

            return vec4(col, density);
        }

        void mainImage(out vec4 fragColor, in vec2 fragCoord) {
            vec2 uv = (fragCoord / iResolution.xy - 0.5) * iResolution.xy / iResolution.y;
            float min_res = min(iResolution.x, iResolution.y);
            vec2 uv2 = (fragCoord * 2.0 - iResolution.xy) / min_res;
            float len = length(uv2);

            vec4 p_col = planet(uv2 / PLANET_RADIUS);
            float z = -sqrt(max(0.0, 0.999 - len * len));
            vec3 norm = vec3(uv2, z);

            // Lighting
            vec3 light = max(0.0, dot(norm, normalize(LIGHT1_POS)) * 0.8 + 0.2) * vec3(1.0);
            light += max(0.0, dot(norm, normalize(LIGHT2_POS)) * 0.8 + 0.2) * vec3(1.0);

            vec4 c_col = clouds(uv2 / PLANET_RADIUS);
            c_col.rgb *= light;
            vec4 a_col = atmosphere(uv2);
            a_col.rgb *= light;

            p_col.rgb *= light;
            vec4 color = mix(p_col, c_col, c_col.a);
            color = mix(color, a_col, a_col.a);
            color.a = clamp(color.a, 0.0, 1.0);

            // Tone mapping (like Neptune)
            color.rgb = color.rgb * 0.9;
            float a = 2.51, b = 0.03, c = 2.43, d = 0.59, e = 0.14;
            color.rgb = clamp((color.rgb * (a * color.rgb + b)) / (color.rgb * (c * color.rgb + d) + e), 0.0, 1.0);

            // Gamma correction
            color.rgb = pow(color.rgb, vec3(0.4545));

            fragColor = vec4(color.rgb, color.a);
        }

        void main() {
            mainImage(gl_FragColor, gl_FragCoord.xy);
        }
    </script>

    <script>
        const canvas = document.getElementById('glcanvas');
        const gl = canvas.getContext('webgl', {alpha: true, premultipliedAlpha: false});
        const PREVIEW_SCALE = new URLSearchParams(window.location.search).get('preview') === '1' ? 0.78 : 1.0;

        if (!gl) { alert('WebGL not supported'); }

        // Enable derivatives extension for fwidth
        gl.getExtension('OES_standard_derivatives');

        function createShader(gl, type, source) {
            const shader = gl.createShader(type);
            gl.shaderSource(shader, source);
            gl.compileShader(shader);
            if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                console.error(gl.getShaderInfoLog(shader));
                gl.deleteShader(shader);
                return null;
            }
            return shader;
        }

        const vsSource = document.getElementById('vs').text;
        const fsSource = document.getElementById('fs').text;

        const vertexShader = createShader(gl, gl.VERTEX_SHADER, vsSource);
        const fragmentShader = createShader(gl, gl.FRAGMENT_SHADER, fsSource);

        const program = gl.createProgram();
        gl.attachShader(program, vertexShader);
        gl.attachShader(program, fragmentShader);
        gl.linkProgram(program);

        if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
            console.error(gl.getProgramInfoLog(program));
        }

        const positionBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([
            -1, -1, 1, -1, -1, 1, -1, 1, 1, -1, 1, 1,
        ]), gl.STATIC_DRAW);

        const positionLocation = gl.getAttribLocation(program, "position");
        gl.enableVertexAttribArray(positionLocation);
        gl.vertexAttribPointer(positionLocation, 2, gl.FLOAT, false, 0, 0);

        gl.useProgram(program);

        const timeLocation = gl.getUniformLocation(program, "iTime");
        const resolutionLocation = gl.getUniformLocation(program, "iResolution");

        function resize() {
            canvas.width = Math.max(1, Math.floor(window.innerWidth * PREVIEW_SCALE));
            canvas.height = Math.max(1, Math.floor(window.innerHeight * PREVIEW_SCALE));
            gl.viewport(0, 0, canvas.width, canvas.height);
            gl.uniform3f(resolutionLocation, canvas.width, canvas.height, 1.0);
        }

        window.addEventListener('resize', resize);
        resize();

        function render(time) {
            gl.uniform1f(timeLocation, time * 0.001);
            gl.drawArrays(gl.TRIANGLES, 0, 6);
            requestAnimationFrame(render);
        }

        requestAnimationFrame(render);
    </script>
</body>
</html>
