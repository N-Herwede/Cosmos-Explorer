<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Black Hole Shader</title>
    <style>
        body { margin: 0; overflow: hidden; background: #000; }
        canvas { width: 100vw; height: 100vh; display: block; }
    </style>
</head>
<body>
    <canvas id="glCanvas"></canvas>

    <script id="fragmentShader" type="x-shader/x-fragment">
        precision highp float;

        uniform vec2 iResolution;
        uniform float iTime;
        uniform vec2 iMouse;

        #define AA 1
        #define _Speed 3.0
        #define _Steps 12.0
        #define _Size 0.3
        #define _Zoom 1.8

        float hash(float x) { return fract(sin(x) * 152754.742); }
        float hash(vec2 x) { return hash(x.x + hash(x.y)); }

        float value(vec2 p, float f) {
            float bl = hash(floor(p * f + vec2(0., 0.)));
            float br = hash(floor(p * f + vec2(1., 0.)));
            float tl = hash(floor(p * f + vec2(0., 1.)));
            float tr = hash(floor(p * f + vec2(1., 1.)));
            vec2 fr = fract(p * f);
            fr = (3. - 2. * fr) * fr * fr;
            float b = mix(bl, br, fr.x);
            float t = mix(tl, tr, fr.x);
            return mix(b, t, fr.y);
        }

        vec4 background(vec3 ray) {
            vec2 uv = ray.xy;
            if (abs(ray.x) > 0.5) uv.x = ray.z;
            else if (abs(ray.y) > 0.5) uv.y = ray.z;

            float brightness = value(uv * 3., 100.);
            float color = value(uv * 2., 20.);
            brightness = pow(brightness, 256.);
            brightness = clamp(brightness * 100., 0., 1.);

            vec3 stars = brightness * mix(vec3(1., .6, .2), vec3(.2, .6, 1), color);
            vec3 nebulae = vec3(0.02, 0.01, 0.04) * (value(uv, 5.0)); // Procedural fallback for iChannel0
            
            return vec4(nebulae + stars, 1.0);
        }

        vec4 raymarchDisk(vec3 ray, vec3 zeroPos) {
            vec3 position = zeroPos;
            float lengthPos = length(position.xz);
            float dist = min(1., lengthPos * (1. / _Size) * 0.5) * _Size * 0.4 * (1. / _Steps) / (abs(ray.y));

            position += dist * _Steps * ray * 0.5;

            vec2 deltaPos;
            deltaPos.x = -zeroPos.z * 0.01 + zeroPos.x;
            deltaPos.y = zeroPos.x * 0.01 + zeroPos.z;
            deltaPos = normalize(deltaPos - zeroPos.xz);

            float parallel = dot(ray.xz, deltaPos);
            parallel /= sqrt(lengthPos);
            parallel *= 0.5;
            float redShift = parallel + 0.3;
            redShift *= redShift;
            redShift = clamp(redShift, 0., 1.);

            float disMix = clamp((lengthPos - _Size * 2.) * (1. / _Size) * 0.24, 0., 1.);
            vec3 insideCol = mix(vec3(1.0, 0.8, 0.0), vec3(0.5, 0.13, 0.02) * 0.2, disMix);
            insideCol *= mix(vec3(0.4, 0.2, 0.1), vec3(1.6, 2.4, 4.0), redShift);
            insideCol *= 1.25;
            redShift += 0.12;
            redShift *= redShift;

            vec4 o = vec4(0.);

            for (float i = 0.; i < _Steps; i++) {
                position -= dist * ray;
                float intensity = clamp(1. - abs((i - 0.8) * (1. / _Steps) * 2.), 0., 1.);
                float lp = length(position.xz);
                float distMult = clamp((lp - _Size * 0.75) * (1. / _Size) * 1.5, 0., 1.);
                distMult *= clamp((_Size * 10. - lp) * (1. / _Size) * 0.20, 0., 1.);
                distMult *= distMult;

                float u = lp + iTime * _Size * 0.3 + intensity * _Size * 0.2;
                float rot = mod(iTime * _Speed, 8192.);
                vec2 xy;
                xy.x = -position.z * sin(rot) + position.x * cos(rot);
                xy.y = position.x * sin(rot) + position.z * cos(rot);

                float safeY = max(abs(xy.y), 0.0008);
                float angle = 0.02 * atan(abs(xy.x), safeY);
                float noise = value(vec2(angle, u * (1. / _Size) * 0.05), 70.);
                float extraWidth = noise * 1. * (1. - clamp(i * (1. / _Steps) * 2. - 1., 0., 1.));
                float alpha = clamp(noise * (intensity + extraWidth) * ((1. / _Size) * 10. + 0.01) * dist * distMult, 0., 1.);

                vec3 col = 2. * mix(vec3(0.3, 0.2, 0.15) * insideCol, insideCol, min(1., intensity * 2.));
                o = clamp(vec4(col * alpha + o.rgb * (1. - alpha), o.a * (1. - alpha) + alpha), vec4(0.), vec4(1.));
                o.rgb += redShift * (intensity * 1. + 0.5) * (1. / _Steps) * 100. * distMult / ((lp / _Size) * (lp / _Size));
            }
            o.rgb = clamp(o.rgb - 0.005, 0., 1.);
            return o;
        }

        void Rotate(inout vec3 vector, vec2 angle) {
            vector.yz = cos(angle.y) * vector.yz + sin(angle.y) * vec2(-1, 1) * vector.zy;
            vector.xz = cos(angle.x) * vector.xz + sin(angle.x) * vec2(-1, 1) * vector.zx;
        }

        void main() {
            vec4 colOut = vec4(0.);
            vec2 fragCoordRot = gl_FragCoord.xy;
            fragCoordRot.x = gl_FragCoord.x * 0.985 + gl_FragCoord.y * 0.174;
            fragCoordRot.y = gl_FragCoord.y * 0.985 - gl_FragCoord.x * 0.174;
            fragCoordRot += vec2(-0.06, 0.12) * iResolution.xy;

            for (int j = 0; j < AA; j++) {
                for (int i = 0; i < AA; i++) {
                    vec3 ray = normalize(vec3((fragCoordRot - iResolution.xy * .5 + vec2(float(i), float(j)) / float(AA)) / (iResolution.x * _Zoom), 1));
                    vec3 pos = vec3(0., 0.05, -(20. * iMouse.x / iResolution.x - 10.) * (20. * iMouse.x / iResolution.x - 10.) * .05);
                    vec2 angle = vec2(iTime * 0.1, .2);
                    angle.y = (2. * iMouse.y / iResolution.y) * 3.14 + 0.1 + 3.14;
                    float d = length(pos);
                    Rotate(pos, angle);
                    angle.xy -= min(.3 / d, 3.14) * vec2(1, 0.5);
                    Rotate(ray, angle);

                    vec4 col = vec4(0.);
                    vec4 glow = vec4(0.);
                    vec4 outCol = vec4(100.);

                    for (int disks = 0; disks < 20; disks++) {
                        for (int h = 0; h < 6; h++) {
                            float dotpos = dot(pos, pos);
                            float invDist = inversesqrt(dotpos);
                            float centDist = dotpos * invDist;
                            float stepDist = 0.92 * abs(pos.y / (ray.y));
                            stepDist = min(stepDist, min(centDist * 0.5, centDist * 0.1 + 0.05 * centDist * centDist * (1. / _Size)));
                            float bendForce = stepDist * invDist * invDist * _Size * 0.625;
                            ray = normalize(ray - (bendForce * invDist) * pos);
                            pos += stepDist * ray;
                            glow += vec4(1.2, 1.1, 1, 1.0) * (0.01 * stepDist * pow(invDist, 4.0) * clamp(centDist * 2. - 1.2, 0., 1.));
                        }
                        float dist2 = length(pos);
                        if (dist2 < _Size * 0.1) {
                            outCol = vec4(col.rgb * col.a + glow.rgb * (1. - col.a), 1.);
                            break;
                        } else if (dist2 > _Size * 1000.) {
                            vec4 bg = background(ray);
                            outCol = vec4(col.rgb * col.a + bg.rgb * (1. - col.a) + glow.rgb * (1. - col.a), 1.);
                            break;
                        } else if (abs(pos.y) <= _Size * 0.002) {
                            vec4 diskCol = raymarchDisk(ray, pos);
                            pos.y = 0.;
                            pos += abs(_Size * 0.001 / ray.y) * ray;
                            col = vec4(diskCol.rgb * (1. - col.a) + col.rgb, col.a + diskCol.a * (1. - col.a));
                        }
                    }
                    if (outCol.r == 100.) outCol = vec4(col.rgb + glow.rgb * (col.a + glow.a), 1.);
                    colOut += pow(outCol, vec4(0.6)) / float(AA * AA);
                }
            }
            gl_FragColor = colOut;
        }
    </script>

    <script>
        const canvas = document.getElementById('glCanvas');
        const gl = canvas.getContext('webgl');

        const vertexShaderSource = `
            attribute vec2 position;
            void main() { gl_Position = vec4(position, 0.0, 1.0); }
        `;

        const fragmentShaderSource = document.getElementById('fragmentShader').text;

        function createShader(gl, type, source) {
            const shader = gl.createShader(type);
            gl.shaderSource(shader, source);
            gl.compileShader(shader);
            return shader;
        }

        const program = gl.createProgram();
        gl.attachShader(program, createShader(gl, gl.VERTEX_SHADER, vertexShaderSource));
        gl.attachShader(program, createShader(gl, gl.FRAGMENT_SHADER, fragmentShaderSource));
        gl.linkProgram(program);
        gl.useProgram(program);

        const buffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([-1,-1, 1,-1, -1,1, -1,1, 1,-1, 1,1]), gl.STATIC_DRAW);

        const positionLocation = gl.getAttribLocation(program, "position");
        gl.enableVertexAttribArray(positionLocation);
        gl.vertexAttribPointer(positionLocation, 2, gl.FLOAT, false, 0, 0);

        const iResolutionLoc = gl.getUniformLocation(program, "iResolution");
        const iTimeLoc = gl.getUniformLocation(program, "iTime");
        const iMouseLoc = gl.getUniformLocation(program, "iMouse");

        let mouseX = 0, mouseY = 0;
        window.addEventListener('mousemove', e => {
            mouseX = e.clientX;
            mouseY = window.innerHeight - e.clientY;
        });

        function render(time) {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            gl.viewport(0, 0, canvas.width, canvas.height);

            gl.uniform2f(iResolutionLoc, canvas.width, canvas.height);
            gl.uniform1f(iTimeLoc, time * 0.001);
            gl.uniform2f(iMouseLoc, mouseX, mouseY);

            gl.drawArrays(gl.TRIANGLES, 0, 6);
            requestAnimationFrame(render);
        }
        requestAnimationFrame(render);
    </script>
</body>
</html>
