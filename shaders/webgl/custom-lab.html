
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Custom Planet Lab Shader</title>
    <style>
        html, body {
            margin: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
            background: #000;
        }

        canvas {
            width: 100%;
            height: 100%;
            display: block;
        }
    </style>
</head>
<body>
    <canvas id="glcanvas"></canvas>

    <script id="vs" type="x-shader/x-vertex">
        attribute vec2 position;
        void main() {
            gl_Position = vec4(position, 0.0, 1.0);
        }
    </script>

    <script id="fs" type="x-shader/x-fragment">
        precision highp float;

        uniform vec3 iResolution;
        uniform float iTime;

        uniform vec3 uPrimaryColor;
        uniform vec3 uSecondaryColor;
        uniform vec3 uAtmosphereColor;
        uniform float uSeed;
        uniform float uRotationSpeed;
        uniform float uBandStrength;
        uniform float uStormStrength;
        uniform float uCloudStrength;
        uniform float uLandStrength;
        uniform float uRockiness;
        uniform float uCraterStrength;
        uniform float uAtmosphereDensity;
        uniform float uTemplate;
        uniform float uPlanetScale;
        uniform float uHaloStrength;
        uniform float uReliefStrength;
        uniform float uSpecularStrength;

        const float PI = 3.14159265359;

        float hash13(vec3 p) {
            p = fract(p * 0.1031);
            p += dot(p, p.yzx + 33.33);
            return fract((p.x + p.y) * p.z);
        }

        float noise3(vec3 p) {
            vec3 i = floor(p);
            vec3 f = fract(p);
            f = f * f * (3.0 - 2.0 * f);

            float n000 = hash13(i + vec3(0.0, 0.0, 0.0));
            float n100 = hash13(i + vec3(1.0, 0.0, 0.0));
            float n010 = hash13(i + vec3(0.0, 1.0, 0.0));
            float n110 = hash13(i + vec3(1.0, 1.0, 0.0));
            float n001 = hash13(i + vec3(0.0, 0.0, 1.0));
            float n101 = hash13(i + vec3(1.0, 0.0, 1.0));
            float n011 = hash13(i + vec3(0.0, 1.0, 1.0));
            float n111 = hash13(i + vec3(1.0, 1.0, 1.0));

            float nx00 = mix(n000, n100, f.x);
            float nx10 = mix(n010, n110, f.x);
            float nx01 = mix(n001, n101, f.x);
            float nx11 = mix(n011, n111, f.x);

            float nxy0 = mix(nx00, nx10, f.y);
            float nxy1 = mix(nx01, nx11, f.y);

            return mix(nxy0, nxy1, f.z);
        }

        float fbm(vec3 p) {
            float value = 0.0;
            float amp = 0.5;
            float freq = 1.0;
            for (int i = 0; i < 5; i++) {
                value += noise3(p * freq) * amp;
                freq *= 2.0;
                amp *= 0.5;
            }
            return value;
        }

        mat3 rotY(float a) {
            float c = cos(a);
            float s = sin(a);
            return mat3(
                c, 0.0, s,
                0.0, 1.0, 0.0,
               -s, 0.0, c
            );
        }

        vec3 applyTemplateBias(vec3 color, float n, float latBand, float templateType) {
            if (templateType < 0.5) {
                return mix(color, color * vec3(1.12, 1.04, 0.92), n * 0.35);
            }
            if (templateType < 1.5) {
                vec3 bands = vec3(0.95, 0.78, 0.58) * latBand;
                return mix(color, bands, 0.45 * latBand);
            }
            if (templateType < 2.5) {
                return mix(color, vec3(0.73, 0.9, 1.0), 0.32 + n * 0.16);
            }
            if (templateType < 3.5) {
                vec3 lavaGlow = vec3(1.0, 0.42, 0.08) * smoothstep(0.6, 1.0, n);
                return mix(color, lavaGlow, 0.45);
            }
            if (templateType < 4.5) {
                vec3 dunes = vec3(0.96, 0.73, 0.43) * (0.35 + 0.65 * latBand);
                return mix(color, dunes, 0.4);
            }
            if (templateType < 5.5) {
                vec3 oceanTint = vec3(0.35, 0.67, 0.96);
                return mix(color, oceanTint, 0.24 + 0.24 * n);
            }
            vec3 dust = vec3(0.72, 0.66, 0.58) * (0.52 + 0.48 * n);
            return mix(color, dust, 0.36);
        }

        vec3 stars(vec2 uv, float seed) {
            vec2 cell = floor((uv + seed) * 240.0);
            float spark = step(0.9965, hash13(vec3(cell, seed)));
            return vec3(spark) * (0.45 + 0.55 * hash13(vec3(cell.yx, seed + 1.7)));
        }

        float craterRings(vec3 p, float frequency, float seed) {
            float n = noise3(p * frequency + vec3(seed));
            float ring = abs(n - 0.5);
            return 1.0 - smoothstep(0.08, 0.2, ring);
        }

        void mainImage(out vec4 fragColor, in vec2 fragCoord) {
            vec2 uv = (fragCoord / iResolution.xy - 0.5) * iResolution.xy / iResolution.y;
            float dist = length(uv);
            float planetScale = clamp(uPlanetScale, 0.65, 1.45);
            float radius = 0.38 * planetScale;
            float haloStrength = clamp(uHaloStrength, 0.0, 1.6);
            float reliefStrength = clamp(uReliefStrength, 0.3, 2.8);
            float specularStrength = clamp(uSpecularStrength, 0.0, 1.8);

            vec3 bg = vec3(0.01, 0.015, 0.03) + stars(uv, uSeed) * 0.6;
            float haloReach = 0.05 + haloStrength * 0.05;

            float planetMask = smoothstep(radius + 0.004, radius - 0.008, dist);
            float outerHaloMask = smoothstep(radius - 0.002, radius + haloReach, dist);
            float z = sqrt(max(0.0, radius * radius - dist * dist));
            vec3 normal = normalize(vec3(uv, z));

            float spin = iTime * 0.16 * uRotationSpeed;
            vec3 samplePos = rotY(spin) * normal;

            float terrainFreq = 1.2 + uLandStrength * 2.3 + uBandStrength * 2.1 + reliefStrength * 0.75;
            float terrain = fbm(samplePos * terrainFreq + vec3(uSeed * 0.013, uSeed * 0.007, uSeed * 0.019));
            float ridge = abs(fbm(samplePos * (terrainFreq * 1.7) + uSeed * 0.029) - 0.5) * 2.0;
            float rockNoise = fbm(samplePos * (4.5 + uRockiness * 3.5 + reliefStrength * 1.3) + vec3(7.0, 19.0, 3.0) + uSeed * 0.031);
            float storms = fbm(samplePos * (6.5 + uStormStrength * 6.4) + vec3(0.0, iTime * 0.24 * (0.35 + uStormStrength), 0.0) + uSeed * 0.021);
            float cloudField = fbm(samplePos * (8.0 + uCloudStrength * 5.6) + vec3(0.0, iTime * 0.065 * (0.35 + uCloudStrength), 0.0) + uSeed * 0.041);
            float latBand = 0.5 + 0.5 * sin(samplePos.y * (4.8 + 8.6 * uBandStrength) + terrain * 3.2);
            float landLow = 0.24 - 0.12 * clamp(uLandStrength / 3.0, 0.0, 1.0);
            float landHigh = 0.86 + 0.1 * (1.0 - clamp(uLandStrength / 3.0, 0.0, 1.0));
            float landBlend = terrain * (0.55 + uLandStrength * 0.48 + reliefStrength * 0.22) + rockNoise * (0.14 + reliefStrength * 0.22) - ridge * 0.12 * reliefStrength;
            float landMask = smoothstep(landLow, landHigh, landBlend);
            float craterField = craterRings(samplePos + vec3(uSeed * 0.0006), 13.0 + uCraterStrength * 12.0, uSeed * 0.002);
            float craterMask = craterField * clamp(uCraterStrength * (0.30 + landMask * 0.9) * (0.6 + 0.35 * reliefStrength), 0.0, 3.0);

            vec3 baseColor = mix(uSecondaryColor, uPrimaryColor, clamp(landMask + latBand * (0.08 + 0.18 * clamp(uBandStrength / 3.4, 0.0, 1.0)), 0.0, 1.0));
            baseColor = mix(baseColor, baseColor * vec3(0.72, 0.68, 0.64), clamp(rockNoise * uRockiness * (0.24 + 0.24 * reliefStrength), 0.0, 1.0));
            baseColor = mix(baseColor, baseColor * vec3(0.36, 0.30, 0.28), craterMask * (0.24 + 0.24 * reliefStrength));
            baseColor = applyTemplateBias(baseColor, terrain, latBand, uTemplate);

            float stormMask = smoothstep(0.48, 0.82, storms) * clamp(uStormStrength * (0.45 + 0.18 * reliefStrength), 0.0, 3.2);
            vec3 stormTint = mix(vec3(1.0), uSecondaryColor, 0.52);
            baseColor = mix(baseColor, stormTint, stormMask * (0.12 + 0.17 * uAtmosphereDensity));
            float cloudMask = smoothstep(0.46, 0.82, cloudField + storms * 0.30) * clamp(uCloudStrength * (0.30 + uAtmosphereDensity * 0.35), 0.0, 3.4);
            vec3 cloudTint = mix(vec3(1.0), uAtmosphereColor, 0.35);
            baseColor = mix(baseColor, cloudTint, cloudMask * 0.68);

            vec3 sunDir = normalize(vec3(0.8, 0.35, 0.6));
            float diffuse = max(dot(normal, sunDir), 0.0);
            vec3 halfDir = normalize(sunDir + vec3(0.0, 0.0, 1.0));
            float specPower = mix(6.0, 28.0, clamp(reliefStrength / 2.8, 0.0, 1.0));
            float spec = pow(max(dot(normal, halfDir), 0.0), specPower) * specularStrength * (0.2 + cloudMask * 0.8);
            float rim = pow(1.0 - max(dot(normal, vec3(0.0, 0.0, 1.0)), 0.0), 2.1 + reliefStrength * 0.35);

            vec3 lit = baseColor * (0.16 + diffuse * 1.08);
            lit += vec3(1.0, 0.98, 0.95) * spec * 0.55;
            lit += uAtmosphereColor * rim * (0.04 + uAtmosphereDensity * 0.08 + haloStrength * 0.05);

            float edgeDist = max(0.0, dist - radius);
            float haloFalloff = mix(34.0, 12.0, clamp(uAtmosphereDensity / 3.0, 0.0, 1.0));
            vec3 atmosphere = uAtmosphereColor * exp(-edgeDist * haloFalloff) * (0.04 + uAtmosphereDensity * 0.11) * haloStrength;
            atmosphere += cloudTint * cloudMask * rim * 0.06 * haloStrength * planetMask;
            atmosphere *= outerHaloMask;

            vec3 color = bg + atmosphere;
            color = mix(color, lit + atmosphere * 0.28, planetMask);

            color = color / (1.0 + color);
            color = pow(color, vec3(0.4545));
            color *= 1.0 - 0.22 * pow(length(uv), 2.0);

            fragColor = vec4(color, 1.0);
        }

        void main() {
            mainImage(gl_FragColor, gl_FragCoord.xy);
        }
    </script>

    <script>
        const canvas = document.getElementById('glcanvas');
        const gl = canvas.getContext('webgl');

        if (!gl) {
            alert('WebGL not supported');
        }

        function createShader(type, source) {
            const shader = gl.createShader(type);
            gl.shaderSource(shader, source);
            gl.compileShader(shader);
            if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                throw new Error(gl.getShaderInfoLog(shader) || 'Shader compile failed');
            }
            return shader;
        }

        function hexToRgb(hex, fallback = [0.7, 0.7, 0.7]) {
            if (!/^#[0-9a-fA-F]{6}$/.test(hex || '')) return fallback;
            return [
                parseInt(hex.slice(1, 3), 16) / 255,
                parseInt(hex.slice(3, 5), 16) / 255,
                parseInt(hex.slice(5, 7), 16) / 255
            ];
        }

        function parseTemplate(templateName) {
            const name = String(templateName || '').toLowerCase();
            if (name === 'gas') return 1;
            if (name === 'ice') return 2;
            if (name === 'lava') return 3;
            if (name === 'desert') return 4;
            if (name === 'ocean') return 5;
            if (name === 'barren') return 6;
            return 0;
        }

        function parseNumber(params, key, fallback, min = null, max = null) {
            const raw = Number.parseFloat(params.get(key));
            if (!Number.isFinite(raw)) return fallback;
            if (min !== null && raw < min) return min;
            if (max !== null && raw > max) return max;
            return raw;
        }

        function clamp(value, min, max) {
            return Math.max(min, Math.min(max, value));
        }

        const params = new URLSearchParams(window.location.search);
        const state = {
            primary: hexToRgb(params.get('primary') || '#7f9dcb'),
            secondary: hexToRgb(params.get('secondary') || '#3d5d8f'),
            atmosphere: hexToRgb(params.get('atmosphere') || '#8fd5ff'),
            seed: parseNumber(params, 'seed', 1337, 0, 9999),
            rotation: parseNumber(params, 'rotation', 0.45, 0.05, 3.2),
            band: parseNumber(params, 'band', 1.0, 0.1, 3.4),
            storm: parseNumber(params, 'storm', 0.8, 0.0, 3.0),
            cloud: parseNumber(params, 'cloud', 0.7, 0.0, 3.2),
            land: parseNumber(params, 'land', 1.0, 0.0, 3.0),
            rock: parseNumber(params, 'rock', 1.0, 0.0, 3.4),
            crater: parseNumber(params, 'crater', 0.75, 0.0, 3.2),
            atmosphereDensity: parseNumber(params, 'atmoDensity', 1.0, 0.0, 3.0),
            planetScale: parseNumber(params, 'planetScale', 1.0, 0.65, 1.45),
            halo: parseNumber(params, 'halo', 0.65, 0.0, 1.6),
            relief: parseNumber(params, 'relief', 1.0, 0.3, 2.8),
            specular: parseNumber(params, 'specular', 0.45, 0.0, 1.8),
            template: parseTemplate(params.get('template'))
        };

        const program = gl.createProgram();
        gl.attachShader(program, createShader(gl.VERTEX_SHADER, document.getElementById('vs').textContent));
        gl.attachShader(program, createShader(gl.FRAGMENT_SHADER, document.getElementById('fs').textContent));
        gl.linkProgram(program);

        if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
            throw new Error(gl.getProgramInfoLog(program) || 'Program link failed');
        }

        gl.useProgram(program);

        const vertexBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([
            -1, -1, 1, -1, -1, 1,
            -1, 1, 1, -1, 1, 1
        ]), gl.STATIC_DRAW);

        const positionLocation = gl.getAttribLocation(program, 'position');
        gl.enableVertexAttribArray(positionLocation);
        gl.vertexAttribPointer(positionLocation, 2, gl.FLOAT, false, 0, 0);

        const uniforms = {
            iResolution: gl.getUniformLocation(program, 'iResolution'),
            iTime: gl.getUniformLocation(program, 'iTime'),
            uPrimaryColor: gl.getUniformLocation(program, 'uPrimaryColor'),
            uSecondaryColor: gl.getUniformLocation(program, 'uSecondaryColor'),
            uAtmosphereColor: gl.getUniformLocation(program, 'uAtmosphereColor'),
            uSeed: gl.getUniformLocation(program, 'uSeed'),
            uRotationSpeed: gl.getUniformLocation(program, 'uRotationSpeed'),
            uBandStrength: gl.getUniformLocation(program, 'uBandStrength'),
            uStormStrength: gl.getUniformLocation(program, 'uStormStrength'),
            uCloudStrength: gl.getUniformLocation(program, 'uCloudStrength'),
            uLandStrength: gl.getUniformLocation(program, 'uLandStrength'),
            uRockiness: gl.getUniformLocation(program, 'uRockiness'),
            uCraterStrength: gl.getUniformLocation(program, 'uCraterStrength'),
            uAtmosphereDensity: gl.getUniformLocation(program, 'uAtmosphereDensity'),
            uTemplate: gl.getUniformLocation(program, 'uTemplate'),
            uPlanetScale: gl.getUniformLocation(program, 'uPlanetScale'),
            uHaloStrength: gl.getUniformLocation(program, 'uHaloStrength'),
            uReliefStrength: gl.getUniformLocation(program, 'uReliefStrength'),
            uSpecularStrength: gl.getUniformLocation(program, 'uSpecularStrength')
        };

        function applyStateToUniforms() {
            gl.uniform3f(uniforms.uPrimaryColor, state.primary[0], state.primary[1], state.primary[2]);
            gl.uniform3f(uniforms.uSecondaryColor, state.secondary[0], state.secondary[1], state.secondary[2]);
            gl.uniform3f(uniforms.uAtmosphereColor, state.atmosphere[0], state.atmosphere[1], state.atmosphere[2]);
            gl.uniform1f(uniforms.uSeed, state.seed);
            gl.uniform1f(uniforms.uRotationSpeed, state.rotation);
            gl.uniform1f(uniforms.uBandStrength, state.band);
            gl.uniform1f(uniforms.uStormStrength, state.storm);
            gl.uniform1f(uniforms.uCloudStrength, state.cloud);
            gl.uniform1f(uniforms.uLandStrength, state.land);
            gl.uniform1f(uniforms.uRockiness, state.rock);
            gl.uniform1f(uniforms.uCraterStrength, state.crater);
            gl.uniform1f(uniforms.uAtmosphereDensity, state.atmosphereDensity);
            gl.uniform1f(uniforms.uTemplate, state.template);
            gl.uniform1f(uniforms.uPlanetScale, state.planetScale);
            gl.uniform1f(uniforms.uHaloStrength, state.halo);
            gl.uniform1f(uniforms.uReliefStrength, state.relief);
            gl.uniform1f(uniforms.uSpecularStrength, state.specular);
        }

        applyStateToUniforms();

        function resize() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            gl.viewport(0, 0, canvas.width, canvas.height);
            gl.uniform3f(uniforms.iResolution, canvas.width, canvas.height, 1.0);
        }

        window.addEventListener('resize', resize);
        resize();

        let paused = false;
        let simulatedTime = 0;
        let lastTimestamp = null;

        window.addEventListener('message', (event) => {
            const data = event.data || {};
            if (data.type === 'pause') paused = true;
            if (data.type === 'play') paused = false;
            if (data.type === 'init' && data.value) {
                paused = !!data.value.paused;
            }
            if (data.type === 'customConfig' && data.value) {
                const incoming = data.value;
                state.primary = hexToRgb(incoming.primaryColor, state.primary);
                state.secondary = hexToRgb(incoming.secondaryColor, state.secondary);
                state.atmosphere = hexToRgb(incoming.atmosphereColor, state.atmosphere);
                const seed = Number.parseFloat(incoming.seed);
                const rotation = Number.parseFloat(incoming.rotationSpeed);
                const band = Number.parseFloat(incoming.bandStrength);
                const storm = Number.parseFloat(incoming.stormStrength);
                const cloud = Number.parseFloat(incoming.cloudStrength);
                const land = Number.parseFloat(incoming.landStrength);
                const rock = Number.parseFloat(incoming.rockiness);
                const crater = Number.parseFloat(incoming.craterStrength);
                const atmosphereDensity = Number.parseFloat(incoming.atmosphereDensity);
                const planetScale = Number.parseFloat(incoming.planetScale);
                const halo = Number.parseFloat(incoming.haloStrength);
                const relief = Number.parseFloat(incoming.reliefStrength);
                const specular = Number.parseFloat(incoming.specularStrength);
                if (Number.isFinite(seed)) state.seed = clamp(seed, 0, 9999);
                if (Number.isFinite(rotation)) state.rotation = clamp(rotation, 0.05, 3.2);
                if (Number.isFinite(band)) state.band = clamp(band, 0.1, 3.4);
                if (Number.isFinite(storm)) state.storm = clamp(storm, 0.0, 3.0);
                if (Number.isFinite(cloud)) state.cloud = clamp(cloud, 0.0, 3.2);
                if (Number.isFinite(land)) state.land = clamp(land, 0.0, 3.0);
                if (Number.isFinite(rock)) state.rock = clamp(rock, 0.0, 3.4);
                if (Number.isFinite(crater)) state.crater = clamp(crater, 0.0, 3.2);
                if (Number.isFinite(atmosphereDensity)) state.atmosphereDensity = clamp(atmosphereDensity, 0.0, 3.0);
                if (Number.isFinite(planetScale)) state.planetScale = clamp(planetScale, 0.65, 1.45);
                if (Number.isFinite(halo)) state.halo = clamp(halo, 0.0, 1.6);
                if (Number.isFinite(relief)) state.relief = clamp(relief, 0.3, 2.8);
                if (Number.isFinite(specular)) state.specular = clamp(specular, 0.0, 1.8);
                state.template = parseTemplate(incoming.template);
                applyStateToUniforms();
            }
        });

        function render(timestamp) {
            if (lastTimestamp === null) lastTimestamp = timestamp;
            const delta = Math.max(0, timestamp - lastTimestamp);
            lastTimestamp = timestamp;
            if (!paused) simulatedTime += delta;

            gl.uniform1f(uniforms.iTime, simulatedTime * 0.001);
            gl.drawArrays(gl.TRIANGLES, 0, 6);
            requestAnimationFrame(render);
        }

        requestAnimationFrame(render);
    </script>
</body>
</html>
